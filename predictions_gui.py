# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'word_predictions.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5 import QtCore, QtWidgets, QtGui
from use_language_model import*
#from expert_system import*
from relation_extraction import*
from qt_material import apply_stylesheet
import csv

# booleans
relation_extraction_is_enabled = False # by default
predicting_words = True # by default
testing_in_progress = False
proper_noun_is_invalid = False

proper_nouns = get_proper_nouns()
proper_noun_index = 1

# counters
accurate_predictions_from_network = 0
accurate_predictions_from_relation_extraction = 0

# not all words from relation extraction are proper nouns
# cause: book spelling mistake, or NLTK mistakes a word for proper noun because it is capitalized
invalid_proper_nouns = 0

def save_test_results():
    """
    Appends the test results in the csv file and prints them in the terminal.
    """

    global accurate_predictions_from_network
    global accurate_predictions_from_relation_extraction
    global invalid_proper_nouns

    with open('test_results.csv', 'a', encoding = 'UTF8') as file:
        writer = csv.writer(file)
        writer.writerow([accurate_predictions_from_network, accurate_predictions_from_relation_extraction, invalid_proper_nouns])
    total = accurate_predictions_from_network + accurate_predictions_from_relation_extraction + invalid_proper_nouns

    # percentages
    net_percent = "{:.2f}".format((accurate_predictions_from_network / total) * 100)
    relex_percent = "{:.2f}".format((accurate_predictions_from_relation_extraction / total) * 100)
    invalid_percent = "{:.2f}".format((invalid_proper_nouns / total) * 100)

    print('Predictions\n==========')
    print(f'Network: {net_percent} %')
    print(f'Relation extraction: {relex_percent} %')
    print(f'\nInvalid proper nouns: {invalid_percent} %\n')

    # reset counters for next test
    accurate_predictions_from_network = 0
    accurate_predictions_from_relation_extraction = 0
    invalid_proper_nouns = 0

class Ui_main_window(object):
    def setupUi(self, main_window):
        """
        Creates all widgets and assigns listeners to them.

        Parameters
            self:
            main_window: QMainWindow object
                The window that will accommodate the gui.
        """

        # main window
        main_window.setObjectName("main_window")
        main_window.resize(700, 500)

        # central widget
        self.centralwidget = QtWidgets.QWidget(main_window)
        self.centralwidget.setObjectName("centralwidget")

        # grid layout
        self.gridLayoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.gridLayoutWidget.setGeometry(QtCore.QRect(30, 30, 551, 311))
        self.gridLayoutWidget.setObjectName("gridLayoutWidget")
        self.gridLayout = QtWidgets.QGridLayout(self.gridLayoutWidget)
        self.gridLayout.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.setObjectName("gridLayout")

        # add label
        self.lbl_user_input = QtWidgets.QLabel(self.gridLayoutWidget)
        self.lbl_user_input.setObjectName("lbl_user_input")
        self.gridLayout.addWidget(self.lbl_user_input, 0, 0, 1, 1)
        
        # add spacer
        spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout.addItem(spacerItem, 2, 0, 1, 1)

        # button to enable relation extraction
        self.btn_enable_relation_extraction = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.btn_enable_relation_extraction.setObjectName("btn_enable_relation_extraction")
        self.gridLayout.addWidget(self.btn_enable_relation_extraction, 1, 4, 1, 1)
        self.btn_enable_relation_extraction.clicked.connect(self.enable_disable_relation_extraction) # click listener

        # add spacer
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem1, 8, 1, 1, 1)

        # add text field
        self.txtfield_user_input = QtWidgets.QLineEdit(self.gridLayoutWidget)
        self.txtfield_user_input.setObjectName("txtfield_user_input")
        self.gridLayout.addWidget(self.txtfield_user_input, 1, 0, 1, 3)
        self.txtfield_user_input.textChanged.connect(self.show_network_predictions) # click listener
        self.txtfield_user_input.textChanged.connect(self.show_relation_extraction_predictions) # click listener

        # label
        self.lbl_prediction_type = QtWidgets.QLabel(self.gridLayoutWidget)
        self.lbl_prediction_type.setObjectName("lbl_prediction_type")
        self.lbl_prediction_type.setText("Predict:")
        self.gridLayout.addWidget(self.lbl_prediction_type, 2, 0, 1, 1)

        # radio buttons
        self.rd_btn_words = QtWidgets.QRadioButton(self.gridLayoutWidget)
        self.rd_btn_words.setObjectName("rd_btn_words")
        self.rd_btn_words.setText("Words")
        self.rd_btn_words.setChecked(True)
        self.rd_btn_words.clicked.connect(self.change_prediction_type)
        self.gridLayout.addWidget(self.rd_btn_words, 3, 0, 1, 1)

        self.rd_btn_phrase = QtWidgets.QRadioButton(self.gridLayoutWidget)
        self.rd_btn_phrase.setObjectName("rd_btn_phrase")
        self.rd_btn_phrase.setText("Phrase")
        self.rd_btn_phrase.clicked.connect(self.change_prediction_type)
        self.gridLayout.addWidget(self.rd_btn_phrase, 4, 0, 1, 1)

        # label
        self.lbl_network_predictions = QtWidgets.QLabel(self.gridLayoutWidget)
        self.lbl_network_predictions.setObjectName("lbl_network_predictions")
        self.gridLayout.addWidget(self.lbl_network_predictions, 8, 0, 1, 1)

        # list of network predictions
        self.list_network_predictions = QtWidgets.QListWidget(self.gridLayoutWidget)
        self.list_network_predictions.setObjectName("list_lstm_predictions")
        self.gridLayout.addWidget(self.list_network_predictions, 9, 0, 5, 2)
        self.list_network_predictions.itemClicked.connect(self.on_prediction_click) # click listener
        self.list_network_predictions.itemClicked.connect(self.on_network_prediction_click) # click listener

        # add label
        self.lbl_relation_extraction_predictions = QtWidgets.QLabel(self.gridLayoutWidget)
        self.lbl_relation_extraction_predictions.setObjectName("lbl_relation_extraction_predictions")
        self.lbl_relation_extraction_predictions.setHidden(True)
        self.gridLayout.addWidget(self.lbl_relation_extraction_predictions, 8, 2, 1, 1)

        # list of relation extraction predictions
        self.list_relation_extraction_predictions = QtWidgets.QListWidget(self.gridLayoutWidget)
        self.list_relation_extraction_predictions.setObjectName("list_expert_system_predictions")
        self.list_relation_extraction_predictions.setHidden(True)
        self.gridLayout.addWidget(self.list_relation_extraction_predictions, 9, 2, 5, 1)
        self.list_relation_extraction_predictions.itemClicked.connect(self.on_prediction_click) # click listener
        self.list_relation_extraction_predictions.itemClicked.connect(self.on_relation_extraction_prediction_click) # click listener

        # add spacer
        spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout.addItem(spacerItem, 15, 0, 1, 1)

        # add label
        self.lbl_amount_of_words = QtWidgets.QLabel(self.gridLayoutWidget)
        self.lbl_amount_of_words.setObjectName("lbl_amount_of_words")
        self.lbl_amount_of_words.setText("Amount of words:")
        self.gridLayout.addWidget(self.lbl_amount_of_words, 5, 0, 1, 1)

        # add spin box
        self.spinbox_amount_of_words = QtWidgets.QSpinBox(self.gridLayoutWidget)
        self.spinbox_amount_of_words.setObjectName("spinbox_amount_of_words")
        self.spinbox_amount_of_words.setValue(3)
        self.gridLayout.addWidget(self.spinbox_amount_of_words, 5, 1, 1, 1)

        # add spacer
        spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout.addItem(spacerItem, 7, 0, 1, 1)

        # add spacer
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem1, 2, 2, 1, 1)

        # button to test prediction accuracy
        self.btn_test = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.btn_test.setObjectName("btn_test")
        self.btn_test.setText("Test")
        self.gridLayout.addWidget(self.btn_test, 17, 0, 1, 1)
        self.btn_test.clicked.connect(self.start_testing)

        # button to report invalid user input (proper noun) during testing
        self.btn_invalid = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.btn_invalid.setObjectName("btn_invalid")
        self.btn_invalid.setText("Invalid")
        self.gridLayout.addWidget(self.btn_invalid, 17, 1, 1, 1)
        self.btn_invalid.setEnabled(False)
        self.btn_invalid.clicked.connect(self.invalid_test_case)
        self.btn_invalid.clicked.connect(self.on_prediction_click)

        main_window.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(main_window)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 615, 21))
        self.menubar.setObjectName("menubar")
        main_window.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(main_window)
        self.statusbar.setObjectName("statusbar")
        main_window.setStatusBar(self.statusbar)

        self.retranslateUi(main_window)
        QtCore.QMetaObject.connectSlotsByName(main_window)

    def retranslateUi(self, main_window):
        """
        Sets the text of the window and labels.

        Parameters
            self:
            main_window: QMainWindow object
                The window that will accommodate the gui.
        """

        _translate = QtCore.QCoreApplication.translate
        main_window.setWindowTitle(_translate("main_window", "Word-Level Predictions"))
        self.lbl_user_input.setText(_translate("main_window", "Type here:"))
        self.lbl_network_predictions.setText(_translate("main_window", "Neural Network Predictions"))
        self.btn_enable_relation_extraction.setText(_translate("main_window", "Enable RE"))
        self.lbl_relation_extraction_predictions.setText(_translate("main_window", "Relation Extraction Predictions"))

    def enable_disable_relation_extraction(self):
        """
        Hides/shows the relation extraction predictions.
        """

        global relation_extraction_is_enabled
        self.btn_enable_relation_extraction.setText("Disable RE" if (self.btn_enable_relation_extraction.text() == "Enable RE") else "Enable RE")
        relation_extraction_is_enabled = not relation_extraction_is_enabled
        self.lbl_relation_extraction_predictions.setHidden(not relation_extraction_is_enabled)
        self.list_relation_extraction_predictions.setHidden(not relation_extraction_is_enabled)

    def change_prediction_type(self):
        """
        Keeps track of whether words or phrases are predicted by the network.
        """

        global predicting_words
        predicting_words = True if (self.rd_btn_words.isChecked()) else False
        self.lbl_amount_of_words.setText("Amount of words:" if (predicting_words) else "Amount of words in phrase:")

    def show_network_predictions(self):
        """
        Populates the list of network predictions with words or a phrase
        depending on what radio button is selected.
        """

        user_input = self.txtfield_user_input.text().lower() # users may type capitals, but the program handles lowercase
        last_char = len(user_input) - 1
        # if the user clears the search bar, clear the predictions
        if (len(user_input) == 0):
            self.list_network_predictions.clear()
        if (last_char > 0 and user_input[last_char] == ' '):           
            self.list_network_predictions.clear()
            # get the predictions
            predictions = list()
            if self.rd_btn_words.isChecked():
                predictions = get_most_probable_next_words(user_input, self.spinbox_amount_of_words.value())
            elif self.rd_btn_phrase.isChecked():
                predictions.append(get_sentence_completion(user_input, self.spinbox_amount_of_words.value()))

            # populate the 'network predictions' list
            self.list_network_predictions.addItems(predictions)

    def show_relation_extraction_predictions(self):
        """
        Populates the list of relation extraction predictions
        with the relations generated by the chunk rule.
        """

        user_input = self.txtfield_user_input.text().lower() # users may type capitals, but the program handles lowercase
        last_char = len(user_input) - 1
        if (len(user_input) == 0):
            self.list_relation_extraction_predictions.clear()
        if (len(user_input) > 0 and user_input[last_char] == ' '):
            self.list_relation_extraction_predictions.clear()
            last_word_given_by_user = user_input.split()[-1]
            self.list_relation_extraction_predictions.addItems(get_relations_to(last_word_given_by_user.capitalize()))

    def start_testing(self):
        """
        Loads the first proper noun into the text field and adds a space so the predictions are loaded.
        """
        global testing_in_progress
        testing_in_progress = True
        self.btn_invalid.setEnabled(True)
        self.txtfield_user_input.setText(proper_nouns[0] + " ")

    def on_network_prediction_click(self):
        """
        Increments the counter of predictions the user chose from the neural network during testing.
        """

        global accurate_predictions_from_network
        accurate_predictions_from_network += 1

    def on_relation_extraction_prediction_click(self):
        """
        Increments the counter of predictions the user chose from relation extraction during testing.
        """

        global accurate_predictions_from_relation_extraction
        accurate_predictions_from_relation_extraction += 1

    def on_prediction_click(self):
        """
        While testing, it keeps track of the selected predictions.
        Once the test finishes, it stores the results in a csv file.
        """

        global proper_noun_index
        global testing_in_progress
        global invalid_proper_nouns
        global proper_noun_is_invalid

        # if user clicks a prediction while no testing takes place, do nothing
        if not testing_in_progress: return
        self.txtfield_user_input.setText(proper_nouns[proper_noun_index] + " ")
        proper_noun_index += 1

        if proper_noun_is_invalid:
            invalid_proper_nouns += 1
            proper_noun_is_invalid = False

        if proper_noun_index == len(proper_nouns):
            proper_noun_index = 1 # reset index for next test
            self.txtfield_user_input.setText("")
            save_test_results()
            testing_in_progress = False
            self.btn_invalid.setEnabled(False)

    def invalid_test_case(self):
        """
        Sets variable proper_noun_is_invalid to True.
        """

        global proper_noun_is_invalid
        proper_noun_is_invalid = True

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    #apply_stylesheet(app, theme = 'dark_blue.xml')
    main_window = QtWidgets.QMainWindow()
    app.setWindowIcon(QtGui.QIcon('deree_blue_32by32.png'))
    ui = Ui_main_window()
    ui.setupUi(main_window)
    main_window.show()
    sys.exit(app.exec_())      
